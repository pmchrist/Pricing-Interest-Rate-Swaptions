What we did:
1st week:   We implemented a very rough of implementation, It was all wrong. We found out that there is a LOT of theory, and we have to do a LOT of reading.

2nd week:   We did simplest HW (Me) and Implemented Swap's Pricing (Sjord). We found out that it was once again wrong, and now with acquired theoretical knowledge we understood the provided syllabus and how we are supposed to price bonds and swaps optimally and how to simulate the HW model better.

3rd week:   Implemented hw/bond/swap/bermudan pricing according to the syllabus (I got carried away and did it all together) + Sjord did first implementation of Greeks. Once again, it was all wrong. A good question was asked by Jori. How do we actually validate the results? We only checked results with an online calculator, which had roughly same results. However, once we started to dig, our results were mostly incorrect.

4th week: After a lot of debugging and rereading theory, issues with bond and swap pricing were solved. Added QuantLib implementation to check if results are valid (it took a lot of time to go through documentation and make sense how it works, how to setup dates, and what to pass where). Still our swaption's value differ from one found with quantlib, but also quantlib does not have the same value as an online calculator + Sjord improved Greeks

5th week: Created visualization, tried to find what is going wrong. Decided that it looks correct. And we better to move away from quantlib, and to implement binomial pricer ourselves. We also now check value of european swaption as a reference. Sjord did presentation and started the report

What we learnt:
    Do not implement features which are not necessary. For example we now have a calibration for yield curve, and HW model which supports it. It took 3 days to make it all work properly. Additionally, to verify results of it we need to do the custom curve in QuantLib and to somehow to verify prices with different curves in the swaption evaluation.
    Do not start next part of implementation before making sure that previous one is 100% working. Errors build up. The "Iterative and Incremental Development" does not work for project where accuracy is top priority. We cannot create barely working Minimum Viable Product and improve on it, it becomes untractable.

What we want to do later:
    Implement Binomial Pricing to verify our price of American Swaption with Longstaff Schwarz
    Experiment with Longstaff Schwarz further, try different predictors from paper (name them)
    Do the Two Factor Hull-White Model and calibrate it (probably off the table, because of arised complications with the pricing verification)
    Improve code, we can make short rate generation faster and minimize variation. We must combine everything into functions and write proper documentation.

How algorithms work:
    - Curves: We have few curves, one of current market from ECB, flat one, upward, and downward.
    - Hull-White (One Factor): We have a drift term, which depends on theta(which depends on the initial yield term structure). We generate drift term for each day and construct multiple paths with multiple days 
    - Follows the syllabus:
    Bond: just takes forward rate curve, short rate at start point and at the beginning of simulation, parameters of HW, and 2 time points: start of payments and maturity
    Swap: takes 3 time points: evaluation, start of payments, maturity. Fixed rate, yield curve, HW parameters, tenor/pay_rate between payments.
    Quantlib, we have custom payment schedule based on Actual/365 calendar. We calculate fixed and floating legs and get the notional price value. The biggest challenge was calendar and to map days from one evaluation to another correctly.
    - Bermudan Swaption
        - Calculate Swap values for each possible execution point of swaption
        - Get forward rates for each path to discount the values at each possible execution point
        - Find realization matrix at last point, and expected cashflow for one before in time (based on the realization matrix, discounted in respect to their forward rates)
        - Fit expected cashflow as independent variable with polynomially transformed short rates of previous time point (only for points in time which are in the money, swap>0)
        - Calculate the realization matrix, if swap>0 and swap>continuation value we should realize and nullify all subsequent cashflows. Else we just keep already expected cashflow and discount it for the previous point of exercise. Update expected cashflow matrix and continue until t=0
        - Discount swap values at the points of exercise in the realization matrix. Average and we have a Bermudan swaption value.
    - European, we just calculate swap values for HW simulated paths and find average


Results:
Possible Explanation for difference with QuantLib swap value is the way we get Theta, we need to check how it is obtained in QuantLib
Additionally, swaption value is deterministic with Hull White model in QuantLib, so is there a close solution?


Simulations: 100, High Variance

(Behaves like simple swap)
Params(Flat, Tm=8, tenor=0.5, r0=0.04, a=0.01, sigma, K, sims):  0.01 0.02 100
100%|██████████| 20/20 [01:50<00:00,  5.52s/it]
Our Bermudan Swaption Value is:  0.12370803370151366 , with a ci: [ 0.12370803370151366 ,  0.12370803370151366 ]
QuantLib Bermudan Swaption Value is:  0.12931582179143458
Our Swap Value is:  0.12370803370151362
Quantlib Swap Value is:  0.128235330528664

(We can see how there is some value, because of variance)
Params(Flat, Tm=8, tenor=0.5, r0=0.04, a=0.01, sigma, K, sims):  0.01 0.04 100
100%|██████████| 20/20 [01:53<00:00,  5.68s/it]
Our Bermudan Swaption Value is:  0.032655286479527965 , with a ci: [ 0.031259713086050314 ,  0.034050859873005615 ]
QuantLib Bermudan Swaption Value is:  0.039097755876575636
Our Swap Value is:  -0.002474403285908977
Quantlib Swap Value is:  0.00253039710915387

(Lower value, higher relative variance)
Params(Flat, Tm=8, tenor=0.5, r0=0.04, a=0.01, sigma, K, sims):  0.01 0.06 100
100%|██████████| 20/20 [01:49<00:00,  5.45s/it]
Our Bermudan Swaption Value is:  0.007222812059977548 , with a ci: [ 0.0065298384652268055 ,  0.007915785654728292 ]
QuantLib Bermudan Swaption Value is:  0.008545298572776482
Our Swap Value is:  -0.12865684027333152
Quantlib Swap Value is:  -0.12317453631035552

Simulations: 100, Low Variance

(Behaves like simple swap)
Params(Flat, Tm=8, tenor=0.5, r0=0.04, a=0.01, sigma, K, sims):  0.002 0.02 100
100%|██████████| 20/20 [01:49<00:00,  5.46s/it]
Our Bermudan Swaption Value is:  0.12370803370151366 , with a ci: [ 0.12370803370151366 ,  0.12370803370151366 ]
QuantLib Bermudan Swaption Value is:  0.12823533052866415
Our Swap Value is:  0.12370803370151362
Quantlib Swap Value is:  0.128235330528664

(We can see how there is some value, much lower because of low variance)
Params(Flat, Tm=8, tenor=0.5, r0=0.04, a=0.01, sigma, K, sims):  0.002 0.04 100
100%|██████████| 20/20 [01:50<00:00,  5.52s/it]
Our Bermudan Swaption Value is:  0.0059491835591827255 , with a ci: [ 0.005745601712972186 ,  0.006152765405393265 ]
QuantLib Bermudan Swaption Value is:  0.008670044988181035
Our Swap Value is:  -0.002474403285908977
Quantlib Swap Value is:  0.00253039710915387

(No values, because of low variance no paths in money)
Params(Flat, Tm=8, tenor=0.5, r0=0.04, a=0.01, sigma, K, sims):  0.002 0.06 100
100%|██████████| 20/20 [01:49<00:00,  5.48s/it]
Our Bermudan Swaption Value is:  0.0 , with a ci: [ 0.0 ,  0.0 ]
QuantLib Bermudan Swaption Value is:  1.2972518244625005e-07
Our Swap Value is:  -0.12865684027333152
Quantlib Swap Value is:  -0.12317453631035552


Simulations: 1000, High Variance

(Still performs as swap)
Params(Flat, Tm=8, tenor=0.5, r0=0.04, a=0.01, sigma, K, sims):  0.01 0.02 1000
100%|██████████| 20/20 [03:20<00:00, 10.05s/it]
Our Bermudan Swaption Value is:  0.12370803370151369 , with a ci: [ 0.12370803370151369 ,  0.12370803370151369 ]
QuantLib Bermudan Swaption Value is:  0.12931582179143458
Our Swap Value is:  0.12370803370151362
Quantlib Swap Value is:  0.128235330528664

(Much smaller discrepancy between evaluations)
Params(Flat, Tm=8, tenor=0.5, r0=0.04, a=0.01, sigma, K, sims):  0.01 0.04 1000
100%|██████████| 20/20 [03:21<00:00, 10.07s/it]
Our Bermudan Swaption Value is:  0.03219615020462856 , with a ci: [ 0.031804812278565804 ,  0.03258748813069131 ]
QuantLib Bermudan Swaption Value is:  0.039097755876575636
Our Swap Value is:  -0.002474403285908977
Quantlib Swap Value is:  0.00253039710915387

(Much smaller discrepancy between evaluations)
Params(Flat, Tm=8, tenor=0.5, r0=0.04, a=0.01, sigma, K, sims):  0.01 0.06 1000
100%|██████████| 20/20 [03:17<00:00,  9.89s/it]
Our Bermudan Swaption Value is:  0.006762636079380653 , with a ci: [ 0.006559959740219263 ,  0.006965312418542043 ]
QuantLib Bermudan Swaption Value is:  0.008545298572776482
Our Swap Value is:  -0.12865684027333152
Quantlib Swap Value is:  -0.12317453631035552

Simulations: 1000, Low Variance

Params(Flat, Tm=8, tenor=0.5, r0=0.04, a=0.002, sigma, K, sims):  0.002 0.04 1000
Did not run, performs as swap even with higher sigma

(In line with earlier)
Params(Flat, Tm=8, tenor=0.5, r0=0.04, a=0.01, sigma, K, sims):  0.002 0.04 1000
100%|██████████| 20/20 [03:19<00:00,  9.98s/it]
Our Bermudan Swaption Value is:  0.005659343687323227 , with a ci: [ 0.005568568760033513 ,  0.005750118614612941 ]
QuantLib Bermudan Swaption Value is:  0.008670044988181035
Our Swap Value is:  -0.002474403285908977
Quantlib Swap Value is:  0.00253039710915387

(Still no path in money)
Params(Flat, Tm=8, tenor=0.5, r0=0.04, a=0.01, sigma, K, sims):  0.002 0.06 1000
100%|██████████| 20/20 [03:17<00:00,  9.88s/it]
Our Bermudan Swaption Value is:  0.0 , with a ci: [ 0.0 ,  0.0 ]
QuantLib Bermudan Swaption Value is:  1.2972518244625005e-07
Our Swap Value is:  -0.12865684027333152
Quantlib Swap Value is:  -0.12317453631035552


Simulations: 10000, High Variance

(We managed to get one out the money path, but it is negligable)
Params(Flat, Tm=8, tenor=0.5, r0=0.04, a=0.01, sigma, K, sims):  0.01 0.02 10000
100%|██████████| 10/10 [09:37<00:00, 57.78s/it]
Our Bermudan Swaption Value is:  0.12370803370151369 , with a ci: [ 0.12370803370151368 ,  0.1237080337015137 ]
QuantLib Bermudan Swaption Value is:  0.12931582179143458
Our Swap Value is:  0.12370803370151362
Quantlib Swap Value is:  0.128235330528664

(Better confidence interval, converges better)
Params(Flat, Tm=8, tenor=0.5, r0=0.04, a=0.01, sigma, K, sims):  0.01 0.04 10000
100%|██████████| 10/10 [09:19<00:00, 55.96s/it]
Our Bermudan Swaption Value is:  0.031896814768757574 , with a ci: [ 0.03170675229210811 ,  0.032086877245407035 ]
QuantLib Bermudan Swaption Value is:  0.039097755876575636
Our Swap Value is:  -0.002474403285908977
Quantlib Swap Value is:  0.00253039710915387

(Better confidence interval, converges better)
Params(Flat, Tm=8, tenor=0.5, r0=0.04, a=0.01, sigma, K, sims):  0.01 0.06 10000
100%|██████████| 10/10 [09:28<00:00, 56.89s/it]
Our Bermudan Swaption Value is:  0.006461760679774336 , with a ci: [ 0.006342447926375401 ,  0.006581073433173271 ]
QuantLib Bermudan Swaption Value is:  0.008545298572776482
Our Swap Value is:  -0.12865684027333152
Quantlib Swap Value is:  -0.12317453631035552

