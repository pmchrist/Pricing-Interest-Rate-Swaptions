What we did:
1st week:   We implemented a very rough of implementation, It was all wrong. We found out that there is a LOT of theory, and we have to do a LOT of reading.

2nd week:   We did simplest HW (Me) and Implemented Swap's Pricing (Sjord). We found out that it was once again wrong, and now with acquired theoretical knowledge we understood the provided syllabus and how we are supposed to price bonds and swaps optimally and how to simulate the HW model better.

3rd week:   Implemented hw/bond/swap/bermudan pricing according to the syllabus (I got carried away and did it all together) + Sjord did first implementation of Greeks. Once again, it was all wrong. A good question was asked by Jori. How do we actually validate the results? We only checked results with an online calculator, which had roughly same results. However, once we started to dig, our results were mostly incorrect.

4th week: After a lot of debugging and rereading theory, issues with bond and swap pricing were solved. Added QuantLib implementation to check if results are valid (it took a lot of time to go through documentation and make sense how it works, how to setup dates, and what to pass where). Still our swaption's value differ from one found with quantlib, but also quantlib does not have the same value as an online calculator + Sjord improved Greeks

5th week: Created visualization, tried to find what is going wrong. Decided that it looks correct. And we better to move away from quantlib, and to implement binomial pricer ourselves. We also now check value of european swaption as a reference. Sjord did presentation and started the report

What we learnt:
    Do not implement features which are not necessary. For example we now have a calibration for yield curve, and HW model which supports it. It took 3 days to make it all work properly. Additionally, to verify results of it we need to do the custom curve in QuantLib and to somehow to verify prices with different curves in the swaption evaluation.
    Do not start next part of implementation before making sure that previous one is 100% working. Errors build up. The "Iterative and Incremental Development" does not work for project where accuracy is top priority. We cannot create barely working Minimum Viable Product and improve on it, it becomes untractable.

What we want to do later:
    Implement Binomial Pricing to verify our price of American Swaption with Longstaff Schwarz
    Experiment with Longstaff Schwarz further, try different predictors from paper (name them)
    Do the Two Factor Hull-White Model and calibrate it (probably off the table, because of arised complications with the pricing verification)
    Improve code, we can make short rate generation faster and minimize variation. We must combine everything into functions and write proper documentation.

How algorithms work:
    - Curves: We have few curves, one of current market from ECB, flat one, upward, and downward.
    - Hull-White (One Factor): We have a drift term, which depends on theta(which depends on the initial yield term structure). We generate drift term for each day and construct multiple paths with multiple days 
    - Follows the syllabus:
    Bond: just takes forward rate curve, short rate at start point and at the beginning of simulation, parameters of HW, and 2 time points: start of payments and maturity
    Swap: takes 3 time points: evaluation, start of payments, maturity. Fixed rate, yield curve, HW parameters, tenor/pay_rate between payments.
    Quantlib, we have custom payment schedule based on Actual/365 calendar. We calculate fixed and floating legs and get the notional price value. The biggest challenge was calendar and to map days from one evaluation to another correctly.
    - Bermudan Swaption
        - Calculate Swap values for each possible execution point of swaption
        - Get forward rates for each path to discount the values at each possible execution point
        - Find realization matrix at last point, and expected cashflow for one before in time (based on the realization matrix, discounted in respect to their forward rates)
        - Fit expected cashflow as independent variable with polynomially transformed short rates of previous time point (only for points in time which are in the money, swap>0)
        - Calculate the realization matrix, if swap>0 and swap>continuation value we should realize and nullify all subsequent cashflows. Else we just keep already expected cashflow and discount it for the previous point of exercise. Update expected cashflow matrix and continue until t=0
        - Discount swap values at the points of exercise in the realization matrix. Average and we have a Bermudan swaption value.
    - European, we just calculate swap values for HW simulated paths and find average
    